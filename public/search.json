[{"title":"Z字形变换","url":"http://yoursite.com/2022/03/10/Z字形变换/","content":"来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zigzag-conversion\n题目描述：\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：\nP   A   H   NA P L S I I GY   I   R之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n示例 1：\n输入：s = “PAYPALISHIRING”, numRows = 3输出：”PAHNAPLSIIGYIR”示例 2：输入：s = “PAYPALISHIRING”, numRows = 4输出：”PINALSIGYAHRPI”解释：P     I    NA   L S  I GY A   H RP     I示例 3：\n输入：s = “A”, numRows = 1输出：”A”\n提示：\n1 &lt;= s.length &lt;= 1000s 由英文字母（小写和大写）、’,’ 和 ‘.’ 组成1 &lt;= numRows &lt;= 1000\n题解：我的想法是，既然最后是按行来读取，那么就可以依次获取每一行的数据放入结果中，那么就需要给每一个元素来一个编号，编号就代表着这个元素的行数，所以可以用一个和s一样长的数组来字母每个元素在那一行，而他们的行数是一串循环的数字，如当总共三行时，行数就依次为0，1，2，1，0，（从0开始），c++代码如下\nclass Solution &#123;public:    string convert(string s, int numRows) &#123;        if(numRows == 1) return s;        int len = s.length();        int x = 0;        int flag = 0;        int p[len];        string ans = &quot;&quot;;        for(int i = 0; i &lt; len; i++)&#123;//这里构造行数数组            if(flag == 0)                p[i] = x++;            else p[i] = x--;            if(x == numRows - 1) flag = 1;            else if(x == 0) flag = 0;        &#125;        for(int k = 0; k &lt; numRows; k++)&#123;            for(int i = 0; i &lt; len; i++)&#123;                if(p[i] == k)                    ans += s[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n","categories":[],"tags":["LeetCode"]},{"title":"考研初始结束","url":"http://yoursite.com/2022/01/04/考研初始结束/","content":"初始结束距离考研初始结束已经过去八天，为什么现在才更新呢，因为我玩了8天哈哈。现在来总结一下考研初始吧。\n政治：对于从小到大都害怕语文的我来讲，政治就只剩下死记硬背，考前三天只背了一套多一点（花了时间，但就是没背下来），最后两天像是掌握了背书技巧一样，直接给背完了，然而政治大题第一题第一问就直接给我整蒙了，偶然与必然，对于这个我只记得选择题选项中出现的偶然寓于必然，没办法，只能硬扯扯了一大堆。后面的题多多少少都背了点，然后就是抄材料。说实话这是我最没把握的一课，上海还是大旱区，希望能多给我点分吧555。\n英语：考英语二的我觉得英语二有点过于简单了，做完了还有一个小时，对的机构答案，选择题就完型错二个，阅读错一个，后面的题我也拿不准，有点后悔作文没有好好准备，希望别扣太多分，这样的话80分应该问题不大。\n数学：今年的数学二整体来讲我也觉得特别简单，就是那个证明题是真不会，记错时间，以为十一点交卷，结果在那坐半天也没收卷子，才意识到十一点半交卷，然后在那干坐半个小时，对的机构答案，除了证明题没做，别的全对，就是有个填空题看错了题目，定积分看成了不定积分，结果把空写满了，发现错误后没办法，只能把正确答案写在横线左下方，希望阅卷老师不要扣我分。关于那个证明题，考完才看到网上说这是1800上面的原题，奈何自己1800是上学期做的，已经过去太长时间了，一点印象都没有，看了下答案，发现自己前半部分思路是对的，就是没有接着往下做（以为是错的，因为看到函数的自变量不一样，没有想到用中值定理），有点可惜。\n专业课：今年的专业课相对来说也是比较简单的（当然没去年简单），唯一考的偏一点的就是那个c程序变成可执行程序的四个过程，我只写了编译和链接，希望少扣点分，然后34记成了add了，这个之前记得很熟的，奈何考前时间全背政治去了，专业课忘的有点多（麻了），这个故事告诉我们政治一定要提早背，不要像我一样考前再抱佛脚。\n总结今天开始要准备复试了，考完之后以为自己会疯玩，但不知为何，有点玩不下去了，感觉游戏也没以前好玩了，现在开始边玩便准备吧，也没有必要太认真，同时也要开始锻炼了，把考研期间累坏的身体给补回来。\n","categories":[],"tags":["考研"]},{"title":"平衡二叉树节点的删除","url":"http://yoursite.com/2021/10/10/平衡二叉树节点的删除/","content":"关于平衡二叉树节点的删除前几天做到了一个平衡二叉树删除节点的题目，看了看王道，没有找到，我就默认跟二叉排序树一样，没右子树直接删除，左子树接上，有右子树就找右子树中序第一个节点接上，结果做错了，然后就去网上查找，找到了正确的方法，这里记录一下。\n","categories":[],"tags":["数据结构"]},{"title":"考研10","url":"http://yoursite.com/2021/10/03/考研10/","content":"关于考研的第10篇博客距离考研还有82天，也是十一假期的最后一天，今天父母来来送了点冬天的衣服，然后吃了个饭，在枯燥的学习生活中也算是有了一点快乐，同时压力开始变大了，撑下去，加油！\n数学：正在查漏补缺，准备重点看下武忠祥老师的选题机巧课，看完之后开始做模拟卷，做就完了。\n专业课：专业课是我比较慌的，准备先吃透真题，搞清楚它要考什么，怎么考，然后再去把知识点系统的整理出来，进行背诵以及复习。\n英语：英二真题整体做下来还是比较简单的，所以并不是很担心，但要开始背作文模板了，每天背一点，到考前就有备无患了。\n政治：进度虽然有点慢，但正在光速追赶，帽子题快速过一遍，理解题快速查知识点，每天学一点，绰绰有余。\n考研人，加油！\nps:突然对美的定义很感兴趣，想知道什么样才叫美呢，等考完研去找点书看一看。\n","categories":[],"tags":["考研"]},{"title":"m叉树的双亲孩子节点编号之间的关系","url":"http://yoursite.com/2021/09/28/m叉树的双亲孩子节点之间的关系/","content":"m叉树的双亲孩子节点编号之间的关系久违的知识博客！\n这个题过第一遍时没搞懂，现在再次看到这个题,我决定把它解决！\n已知双亲结点的编号为i（根节点为1），求这个结点的第一个孩子的编号。\n设树的高为h，则从第一层到h-1层的结点总数为(m^(h-1) - 1)/ (m - 1)\n则在h层的i之前的结点共有i - (m^(h-1) - 1)/ (m - 1) - 1个\n那么所求孩子结点的那一层在他前面共有节点 m * [ i - (m^(h-1) - 1)/ (m - 1) - 1]个结点\n而1到h层共有(m^h - 1)/ (m - 1)个结点\n所以要求的编号j = (m^h - 1)/ (m - 1) + m  [ i - (m^(h-1) - 1)/ (m - 1) - 1] + 1 = m  (i - 1) + 2\n即j = m * (i - 1) + 2\n如果已知孩子节点编号，求双亲节点编号，直接解一下即可。\n","categories":[],"tags":["数据结构"]},{"title":"关于自己考研以来的一些思考","url":"http://yoursite.com/2021/09/17/关于自己考研以来的一些思考/","content":"1，保研这个其实是最近才有一个很真实的感受，我多么希望有人在大一就告诉我这些（虽然我大概率也不会听），本人成绩算是在上游，没挂过科（体育考了一次63哈哈），这次保研\n","categories":[],"tags":["随笔"]},{"title":"考研9","url":"http://yoursite.com/2021/09/17/考研9/","content":"关于考研的第九篇博客又是时隔一个多月的更新，这个月发生了蛮多事情，记录一下。\n第一，华理公共课改了！数一英一变成数二英二（专硕）！虽然很无奈，但是怀着对专硕的热爱，我毅然决然的选择了跟着转，就是可惜了之前买的复习资料，第二就是上大缩招（专硕直接缩到20多人，我一不考的都觉得离谱），上大缩招带来的最直接的影响就是上大难免冲向华理，同时华理还改公共课，就像是在和上大打配合一样，麻了，不过不是很清楚群里为什么没人改冲东华呢，感觉今年东华热度很低（个人观点），还有一些琐碎但影响不大的事情，比如去年科软失败的难免二战集体冲向华理，群里自己说的16人，感觉就是来搞心态的，而且我觉得他们不一定考很高。\n学习情况总结​        数学：转战数二虽然对我来说是浪费了大量的时间，但好在数一转数二还是很轻松的，目前在做真题，最明显的感受就是真题有点简单，一方面可能是我还只做到了09年，那时的难度本来就不高，还有就是平时的练习中参杂了很多真题或者和真题类似的题目，所以做的很轻松，去年客观题加到了80分，但我感觉自己的客观题做的还是不快的，需要找个机会加强一下。\n​        专业课：专也算是步入正轨了，这个月把计组结束之后开始尝试做真题，然后再把三门知识点过一遍感觉就没有大问题了，相对来说时间还是比较充裕。\n​        英语：英语从数一转到英二，对我来说最直接的感受就是无缝衔接，哈哈，我英语真题刚好也只到了12年，直接再从10年开始做英语二真题就可以了，感觉单词这方面还是要加强，同时打算下个月开始背作文。\n​        政治：在做1000题，每天做一点，问题应该不大，但是离做完还有一定距离，做完之后二刷一遍就差不多了。\nps:为什么我感觉操场上跑步比跑步机上跑步要累好多好多呢，家里跑完一点感觉没有，操场跑完气喘吁吁，淦。\n","categories":[],"tags":["考研"]},{"title":"考研8","url":"http://yoursite.com/2021/07/29/考研8/","content":"关于考研的第八篇博客好久没更新了，主要是在家懒得开电脑，今天借着写报告的时间写下博客- -\n数学：复习全书高数部分还差三章，进度比我想象的要慢一些，争取10天结束高数。\n英语：现在做到了09年的阅读，进度还算可以，准备把最后几年的卷子留下来练手，所以差不多做了一半，单词明天就算过完了一遍，准备之后直接背真题里不会的词，不整个的去背了。\n专业课：专业课是我最担心的，主要是进度有点慢，准备之后把数学的世家分点给专业课了，毕竟都是150分，不能偏科啊。\n政治：政治已经开始几天了，每天花半个小时左右去看视频和做题，一千题也到手了，感觉不用担心。\nps:慢慢来，才更快，考研加油\n","categories":[],"tags":["考研"]},{"title":"格雷编码","url":"http://yoursite.com/2021/06/24/格雷编码/","content":"89.格雷编码n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：\n\n每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）\n第一个整数是 0\n一个整数在序列中出现 不超过一次\n每对 相邻 整数的二进制表示 恰好一位不同 ，且\n第一个 和 最后一个 整数的二进制表示 恰好一位不同\n\n给你一个整数 n ，返回任一有效的 n 位格雷码序列 。\n示例 1：\n输入：n &#x3D; 2输出：[0,1,3,2]解释：[0,1,3,2] 的二进制表示是 [00,01,11,10] 。- 00 和 01 有一位不同- 01 和 11 有一位不同- 11 和 10 有一位不同- 10 和 00 有一位不同[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。- 00 和 10 有一位不同- 10 和 11 有一位不同- 11 和 01 有一位不同- 01 和 00 有一位不同\n示例 2：\n输入：n &#x3D; 1输出：[0,1]\n思路：先把前几个写出来看一看\nn = 1\n0\n\n1\nn = 2\n00\n01\n\n11\n10\nn=3\n000\n001\n011\n010\n\n110\n111\n101\n100\n可以看到 n+1就是把n的所有数字最高位变成1，其他的位置镜像翻转过来，根据这个规律我们就可以写出代码\nc++代码：\nclass Solution &#123;public:    vector&lt;int&gt; grayCode(int n) &#123;        vector&lt;int&gt; ans;        ans.push_back(0);        ans.push_back(1);        int x = 2;        for(int i = 0; i &lt; n - 1; i++)&#123;            for(int j = x - 1; j &gt;= 0; j--)&#123;                ans.push_back(ans[j] + x);            &#125;            x *= 2;        &#125;        return ans;    &#125;&#125;;\n","categories":[],"tags":["LeetCode"]},{"title":"考研7","url":"http://yoursite.com/2021/06/10/考研7/","content":"关于考研的第七篇博客最近是真的热，关键这图书馆空调效果还这么差，真的是折磨人，去别的学校试了下他们呢图书馆空调，对比真的明显，无奈只能尝试在寝室学习了。\n数学：\n看完了高数强化课程，看的时候有题目就暂停，尝试做出来，然后再听讲，所以还是做了些题目（但是肯定不够），目前在看线代的强化课程，准备把课都看完了之后开始系统的做题。\n英语：\n后天就考六级了，说实话没怎么准备，希望不要比上次低，哈哈。对于考研来讲的话，相比之前做真题的速度变快了，目前感觉还可以。\n专业课：\n停滞了好几天了，主要是专业课时间安排在了晚上，最近晚上又蹦出来一些实验，图书馆又热，所以一拖再拖，正在想办法解决。\n政治：\n还没开始，下次一定OvO。\n希望快点暑假吧，这天气真的不想天天跑图书馆，太折磨了。\n","categories":[],"tags":["考研"]},{"title":"考研6","url":"http://yoursite.com/2021/06/01/考研6/","content":"关于考研的第六个博客到了6月1号了，考研的时间过来将近三分之一，所以来写个博客记录一下\n数学:\n在看高数强化课视频，目前是准备看完了之后买本李正元复习全书做一做，听说还挺好的,争取这个月把强化课看完。\n英语：\n真题进度巨慢，到现在才做了一套半真题，主要是因为把英语真题时间安排到了晚上，而晚上总有些乱七八糟的事情，还要学专业课，得试着强迫自己去做真题了（说了好多遍了，这次是真的）。\n专业课：\n在看计组，说实话，看的一脸懵，但还是要看，没办法，慢慢来吧\n政治：\n下次一定OvO\n","categories":[],"tags":["考研"]},{"title":"考研5","url":"http://yoursite.com/2021/05/22/考研5/","content":"记录下这魔幻的一天上午正常的在图书馆呆着，中午看了眼手机，有人说袁隆平去世了，吓我一跳，但很快就有人出来辟谣，瞬间对造谣的媒体愤怒不已（好像还是央媒），但很快到了一点多的时候，又说袁老爷爷是真的去世了，这次没人辟谣了，因为是事实，随后又在群里看到了一个视频，一辆汽车冲向正在过马路的人群，瞬间撞飞好几人，导致四人死亡，三人受伤，看着让人十分害怕，又看了下群，发现中国肝脏外科之父吴孟超也去世了，我的妈，到了下午约好了房产中介去看房，房子都看了两个了然后说不能短租，麻了，实在是麻了。\n关于考研数学：\n错题重做（高数）还差三章，预计下周做完，然后看去年的提高阶段视频。\n英语：\n准备先把精翻停一下，先做几套真题再说，单词照背。\n专业课：\n几天前过完了数据结构，但计组还没开始，计组内容和王道书差的好像还挺多，说实话有点不知道怎么复习，准备好好的看一下。\n政治：\n想了一下，但还没开始。。。\nps:下星期有一门考试，要好好的准备一下，所以复习进度要慢一点了。\n\n5月24日晚写 租房后续\n今天上午九点多中介打电话给我朋友，说有人想转租，刚好一个月，但刚好他又上课，只能下课细聊，等到下课发消息过来说还有人也想要，所以要尽快，本来说是晚上或着明天一起去看看的，但怕被抢，于是我就加上了中介的微信，打算独自去看一下，不错的话就直接签了，没想到快走到校门的时候，中介一个微信打过来，告诉我不用去了，房子已经被人租走了，我顿时傻了眼，他说租房的那个人知道之后直接两分钟干到了他们店里去把房租了。。。无奈只能无功而返，只能说租到房的那个人是真的果断，是在下输了，人麻了。这个故事告诉我们一旦决定要做的时候，就要以最快的速度去做，不然就会被别人捷足先登OvO.\n","categories":[],"tags":["考研"]},{"title":"考研004","url":"http://yoursite.com/2021/05/09/考研之旅004/","content":"关于考研的第四篇博客天气热了起来，开始折磨了，热的人心也开始烦躁了，希望图书馆早点开空调吧\n数学：\n​        基础过了一遍，现在要开始复习跟总结一下了（感觉忘得差不多了），主要是把错题重做一遍以及把该记的公式全部记一下，会花多久也不清楚，尽量在五月份搞完吧。\n英语：\n​        真题还只做了一套，得加快速度了，同时背单词。\n专业课：\n​        说好的上个月看完数据库，但现在还有两章，感觉会不知不觉的忘掉还要学专业课，看来是需要一个时间表啥的了（这几天看完数据结构）。\n政治：\n​        没开始。\n最近可能会考虑更一些数据结构的技术性文章（自己没忘记的话）。\n","categories":[],"tags":["考研"]},{"title":"人的三个20岁","url":"http://yoursite.com/2021/04/25/人的三个20岁/","content":"随便写写这是我在被室友的键盘声吵醒时的突发奇想，便想着第二天写个博客，哈哈\n前情提要:自己其实也就20出头，没那没多的人生阅历，写着玩玩，不喜勿喷 \n人生大抵也就3个20多岁\n​        第一个20多岁是从你呱呱落地到你有了自己的第一个孩子，对于大多数人来讲，这20多岁是最安全最舒服的20多岁，也是最没有主见的20多岁。一直活在父母的庇护之下，无需为生活操心，也无需为自己的言行负责。在这20多年当中，学习是主旋律，从小学到初中，从高中到大学，多数人还会选择考研，但最开始其实我们也不知道为什么要学习，也没有想过，只知道，学习就对了，事实也是如此，在毕业后展现得尤为清楚。\n​        第二个20多岁是从你第一个孩子出生到你的孩子的孩子出生，对于大多数人来讲，这20多岁是压力骤增的20多岁，也是最有机会成功的20多岁，在这20多年，你要考虑买房，买车，照顾父母，养育孩子，总的来说，就是赚钱加教育，你身上扛着3代人的压力，为此你必须努力，虽然不一定成功，但也必须努力，你已经不止是你自己，努力过后，有一小部分人会变成别人眼里的成功人士，月入百万，豪车别墅，但真的算不算成功呢，其实只有他自己知道。\n​        第三个20多岁是你的孙子出生到你的生命结束，这可能是你最舒适的20多岁，也可能是你最痛苦的20多岁。你此时就快到了退休的年龄，或者已经退休，只等着安享晚年，子女已经长大成人，无需过多操心，每天跟老伴过好自己就行，虽然年事已高，但只要是你想做的事，努努力还是能做到的毕竟，此时不做，更待何时呢。同时你也会遭受病痛的折磨，年轻时留下的病根子接二连三的暴露出来，这时你会意识到，留给你的时间可能已经不多了，尽量做完想做的事情，就可以安享晚年了，盼望着儿女不时的看望，平时就看看电视，打打游戏，等待着人生的结束。\n","categories":[],"tags":["随笔"]},{"title":"考研003","url":"http://yoursite.com/2021/04/19/考研之旅003/","content":"关于考研的第三篇博客数学：\n​        刷完了线代，感觉线代内容是相对偏少的，已经开始概率论，但是对应的网课好像还没出，只能拿去年的看看了哈哈。\n英语：\n​        目前是背单词加做真题，但是真题做的有点慢，一篇阅读要么就是文章里的词很多不认识，要么就是选项里很多不认识，很绝望，所以还是要加紧背单词哈哈。\n专业课：\n​        目前是慢慢的在把专业课的时间往上加，争取在这个月把数据结构第一遍搞定，毕竟感觉自己还是有点底子，看的还是蛮快的。\n政治：\n​        依旧没开始哈哈\nps:这个博客本来是昨天就该写的，但是昨天去参加了蓝桥杯然后下午加晚上去了楚河汉街看比赛，所以拖到了今天晚上哈哈。（看比赛还是很开心的，现场气氛是真的好，就是单词累积到了今天，导致今天背了好久的单词，人要背傻了，所以以后要尽量避免这种情况，最少要把复习部分的单词看完）\n","categories":[],"tags":["考研"]},{"title":"考研002","url":"http://yoursite.com/2021/04/04/考研之旅002/","content":"关于考研的第二篇博客数学：终于在今天做完了1800高数基础，明天开始线代，刚好书昨天到了，争取这个月把线代基础过完，快点开始概率论\n英语：还在背单词，打算在本月做下真题，看下阅读试试手，当然单词也在背（刚买的黄皮书的厚度吓到我了`(&gt;﹏&lt;)′）\n专业课：好久没看了，得找个时间看，这样下去也不是办法\n政治：还没开始😆😆😆\n","categories":[],"tags":["考研"]},{"title":"考研001","url":"http://yoursite.com/2021/03/14/考研之旅001/","content":"关于考研的第一篇博客目前学习状态还可以(～￣▽￣)～\n但从明天开始要上课了，效率肯定会有所下降，目前目标是在四月之前把高数1800基础题做完（现在还在做定积分，所以有点难，但可以争取一下）\n英语单词每天在背，不过照现在这个速度得到7月份才能背完，准备下月开始做一下关于英语阅读方面的练习\n专业课在慢慢的看课，自己当初学的还可以（感谢我的老师），所以学起来感觉还是很轻松的（除了计组。。。）\n至于政治，还没开始，应该还不急，哈哈。睡了睡了\n","categories":[],"tags":["考研"]},{"title":"hexo操作","url":"http://yoursite.com/2020/12/11/hexo操作/","content":"怕自己忘了，所以在这里写一下OVO新建bloghexo new &quot;博客名&quot;启动本地服务hexo server //可以简写成hexo s遇到问题就用以下三步hexo clean //清除部署緩存,可以简写成hexo chexo generate //生成静态页面至public目录,可以简写成hexo ghexo deploy //将.deploy目录部署到GitHub,可以简写成hexo d\n","categories":[],"tags":[]},{"title":"基本JAVA_WEB项目","url":"http://yoursite.com/2020/07/29/基本JAVA-WEB项目/","content":"Javaweb实训学习由于疫情原因只能呆在家，但也阻止不了学校的实习呀，本次实习采用网上教学的方式,老师讲的东西有点多，在这里总结一下。\n1，准备工作安装好JDK,Mysql,eclipse或idea,navicat,tomcat（最基础的版本，没有用到框架）\n2,大致流程1,需求分析\n对你的目标项目做一个大致分析，找出需要可能需要实现的功能。        \n2,页面设计\n设计出最终项目的所有静态页面，在实际项目中一般用于做展示。\n3，数据库设计\n根据你要实现的功能设计出对应的数据库表结构\n4，实际代码编写\n将代码部署到tomcat上，在本地进行查看与调试\n3，详细流程（以KFC网页端点餐为例）1，需求分析\n要点餐，首先要登陆，然后要将要点的东西加入购物车，最后进行结算。\n想要快速的找到商品，分类与搜索是必须要的，同时需要能够查看到商品详情。\n对于购物车中的货物可以经行勾选，勾中才会结算，同时在购物车页面实现商品数量的加减\n对于之前的订单可以在历史订单中找到，在历史订单详情页中找到自己之前买了啥\n2，页面设计\n包含登陆页面，主页面，商品页，商品详情页，购物车页面，历史订单页，订单详情页\n在设计这些页面时会用到jstl以及er表达式，需要添加依赖包以及在jsp文件开始加上一段说明\n3，数据库设计\n要能登陆，需要user表经行登陆判断\n显示商品，需要一个food表，以及foodtype商品分类表\n显示订单需要order表，以及orderdetail订单详情表\n这里在实际中对于外键并没有直接设置，而是在创建一个键，用0，1表示这个数据是否存在，便于数据的删除，但在这里为了简便，没有经行类似的设置。\n4，实际代码编写\n在eclipse创建一个JAVA项目\n首先是与数据库建立连接,即JDBC,需要提前导入JDBC对应的的依赖包，在properties中配置好信息后，创建一个工具类来封装JDBC的方法来建立连接，然后创建实体层entity来与数据库中的表相对应，DAO层写入对应的方法（这里的方法只能是直接用sql语句就能完成的方法），然后在DAOImpl中实现这些方法，正常流程是再创建service层来封装更高级的方法，由于这个项目的方法需求比较简单，所以直接调用DAO层方法来实现就行。在conroller层中编写servlet与用户的需求经行对接，正常时是调用service层方法，这里为了简单直接调用DAO层方法。\n\n代码下载 提取码adsi\n我的个人博客 amazingz6.github.io我的bilibili https://space.bilibili.com/66908429我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories\n","categories":[],"tags":[]},{"title":"N皇后","url":"http://yoursite.com/2020/06/12/N皇后/","content":"51. N 皇后难度困难1219\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。\n示例 1：\n\n输入：n &#x3D; 4输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释：如上图所示，4 皇后问题存在两个不同的解法。\n示例 2：\n输入：n &#x3D; 1输出：[[&quot;Q&quot;]]\n提示：\n\n1 &lt;= n &lt;= 9\n\n来源:leetcode\n51. N 皇后 - 力扣（LeetCode） (leetcode-cn.com)\n思路：之前写过n皇后，不过是只用算出有多少种情况，这题是要把棋盘给画出来，不过大差不差。大致思路还是dfs加回溯，在递归的时候检查当前位置的正上方有没有皇后（这里是从上到下一行一行来所以不用考虑下方），左上方一条线有没有皇后，右上方一条线有没有皇后，没有就可以进入下一层递归。\nc++代码：\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; ans;    vector&lt;string&gt; temp;    int size;    void dfs(int n)&#123;        if(n == size)&#123;            ans.push_back(temp);            return;        &#125;        for(int i = 0; i &lt; size; i++)&#123;            string s;            int flag = 0;            for(int j = 0; j &lt; n; j++)&#123;                if(temp[j].at(i) == &#x27;Q&#x27;)&#123;//当前位置上方                    flag = 1;                    break;                &#125;                    if(i + n - j &lt; size)&#123;                    if(temp[j].at(i + n - j) == &#x27;Q&#x27;)&#123;//当前位置右上方                        flag = 1;                        break;                    &#125;                &#125;                if(i - n + j &gt;= 0)&#123;                    if(temp[j].at(i - n + j) == &#x27;Q&#x27;)&#123;//当前位置左上方                        flag = 1;                        break;                    &#125;                &#125;            &#125;            if(flag) continue;            for(int j = 0; j &lt; i; j++) s += &quot;.&quot;;            s += &quot;Q&quot;;            for(int j = i + 1; j &lt; size; j++) s += &quot;.&quot;;            temp.push_back(s);            dfs(n + 1);            temp.pop_back();//回溯        &#125;    &#125;    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        size = n;        dfs(0);        return ans;    &#125;&#125;;\n","categories":[],"tags":["LeetCode"]},{"title":"LeetCode 字符串转换整数 (atoi)","url":"http://yoursite.com/2020/05/05/LeetCode-字符串转换整数-atoi/","content":"LeetCode 字符串转换整数 (atoi)题目描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：\n\n如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。\n假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。\n该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。\n\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0 。\n提示：\n\n本题中的空白字符只包括空格字符 &#39; &#39; 。\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n\n示例 1:\n输入: &quot;42&quot;输出: 42\n示例 2:\n输入: &quot;   -42&quot;输出: -42解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n示例 3:\n输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。\n示例 4:\n输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。     因此无法执行有效的转换。\n示例 5:\n输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。      因此返回 INT_MIN (−231) 。\n其实这个就是官方题解，我觉得很巧妙，所以来分享一下\n他采用了自动机的方法（本人刚好在学编译原理哈哈哈），将所有的状态分为四类 start(起始状态)，signed（’+’或’-‘号）,number(数字)，end(结束状态)\n具体的状态之间的转换如下表\n\n\n\n\n\n‘ ‘\n+/-\nnumber\nother\n\n\n\n\nstart\nstart\nsigned\nin_number\nend\n\n\nsigned\nend\nend\nin_number\nend\n\n\nin_number\nend\nend\nin_number\nend\n\n\nend\nend\nend\nend\nend\n\n\n\n\nclass Automaton &#123;    string state = &quot;start&quot;;    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;//状态转换表，与上表对应        &#123;&quot;start&quot;, &#123;&quot;start&quot;, &quot;signed&quot;, &quot;in_number&quot;, &quot;end&quot;&#125;&#125;,        &#123;&quot;signed&quot;, &#123;&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;&#125;&#125;,        &#123;&quot;in_number&quot;, &#123;&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;&#125;&#125;,        &#123;&quot;end&quot;, &#123;&quot;end&quot;, &quot;end&quot;, &quot;end&quot;, &quot;end&quot;&#125;&#125;    &#125;;    int getchar(char c)&#123;//与上面的无向图对应，决定了无向图二维下标        if(isspace(c)) return 0;//为空格        if(c == &#x27;+&#x27; or c == &#x27;-&#x27;) return 1;//为 &#x27;+&#x27;,&#x27;-&#x27;        if(isdigit(c)) return 2;//为数字        return  3;//为其他    &#125;public:    int sign = 1;//初始为1，因为当没有&#x27;+&#x27;,&#x27;-&#x27;号时默认是正数    long long ans = 0;    void getc(char c)&#123;        state = table[state][getchar(c)];//找到对应的下一个状态        if(state == &quot;in_number&quot;)&#123;//判断如果是数字，就将当前数字加入结果中            ans = ans * 10 + c - &#x27;0&#x27;;            ans = sign == 1 ? min((long long)INT_MAX, ans) : min(-(long long)INT_MIN, ans);//判断是否超出范围是正数则与INT_MAX比较，负数则与INT_MIN比较        &#125;        if(state == &quot;signed&quot;)&#123;//如果当前是&#x27;+&#x27;或&#x27;-&#x27;            if(c == &#x27;+&#x27;) sign = 1; //1表示正数            else sign = -1;//-1表示负数        &#125;//其他情况不用写出来，因为到了end状态后就只可能到达end状态，不会到达任何有用的状态，或者说除了上面两个状态之外的状态不需要做任何的操作    &#125;    &#125;;class Solution &#123;public:    int myAtoi(string str) &#123;        Automaton automaton;        for(char c:str)            automaton.getc(c);        return automaton.sign * automaton.ans;//与符号位相乘，决定他的正负    &#125;&#125;;\n转载自leetcode\n我的个人博客 amazingz6.github.io我的bilibili https://space.bilibili.com/66908429我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories\n","categories":[],"tags":["LeetCode"]},{"title":"填写运算符问题","url":"http://yoursite.com/2020/05/04/填写运算符问题/","content":"填写运算符问题问题描述：输入任意五个数x1,x2,x3,x4,x5每两个相邻数之间填上一个运算符。在填入4个运算符“+，-，*，/”后，使得表达式为一个指定值y（y由键盘键入），求出所有满足条件的表达式。\n这里我采用书上的穷举法来解决，用for循环遍历所有情况，因为有4个运算符，所以有4层for循环，因为有4种运算符，所以每一个循环循环4次。\n在每次处理运算符时，如果是+，-号就将该符号前的运算结果存在p中，如果是*，/号就将乘法和除法的部分得到的结果存在q中，以此来进行符号之间的优先级判断。\n代码#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123;    int i[5];    double n[6];    int p, q, f, k;    int total = 0;    char c[5] = &#123;&#x27; &#x27;, &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;&#125;;    cout &lt;&lt; &quot;请输入参与运算的五个数：&quot; &lt;&lt; endl;    for(int j = 1; j &lt;= 5; j++)&#123;        cin &gt;&gt; n[j];    &#125;    cout &lt;&lt; &quot;请输入运算的结果：&quot; &lt;&lt; endl;    cin &gt;&gt; n[0];    for(i[1] = 1; i[1] &lt;= 4; i[1]++)&#123;        if(!(i[1] == 4 &amp;&amp; n[2] == 0))//考虑当当前符号为&#x27;/&#x27;且该符号后面为零时则不可取，下同            for(i[2] = 1; i[2] &lt;= 4; i[2]++)&#123;                if(!(i[2] == 4 &amp;&amp; n[3] == 0))                    for(i[3] = 1; i[3] &lt;= 4; i[3]++)&#123;                        if(!(i[3] == 4 &amp;&amp; n[4] == 0))                            for(i[4] = 1; i[4] &lt;= 4; i[4]++)&#123;                                if(!(i[4] == 4 &amp;&amp; n[5] == 0))&#123;                                    p = 0;//用p存储+ -运算得到的结果                                    q = n[1];//用p存储* /运算得到的结果                                    f = 1;//用来表示是加法运算还是减法运算                                    for(k = 1; k &lt;= 4; k++)&#123;                                        if(i[k] == 1)&#123;//为+号时                                            p += f * q;                                            f = 1;                                            q = n[k + 1];                                        &#125;                                        else if(i[k] == 2)&#123;//为-号时                                            p += f * q;                                            f = -1;                                            q = n[k + 1];                                        &#125;                                        else if(i[k] == 3)&#123;//为*号时                                            q = q * n[k + 1];                                        &#125;                                        else if(i[k] == 4)&#123;//为/号时                                            q = q / n[k + 1];                                        &#125;                                    &#125;                                    if(p + f * q == n[0])&#123; //处理最后一个出现的+号或-号，处理之后得到的就是最终的结果，然后经行比较                                        total++;                                        cout &lt;&lt; total &lt;&lt; &#x27;:&#x27;;                                        for(int j = 1; j &lt;= 4; j++)&#123;                                            cout &lt;&lt; n[j] &lt;&lt; c[i[j]];                                        &#125;                                        cout &lt;&lt; n[5] &lt;&lt; &#x27;=&#x27; &lt;&lt; n[0] &lt;&lt; endl;                                    &#125;                                &#125;                            &#125;                    &#125;            &#125;    &#125;    cout &lt;&lt; &quot;共有&quot; &lt;&lt; total &lt;&lt; &quot;种方法&quot; &lt;&lt; endl;    return 0;&#125;\n我的个人博客 amazingz6.github.io我的bilibili https://space.bilibili.com/66908429我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories\n","categories":[],"tags":[]},{"title":"颜色分类","url":"http://yoursite.com/2020/04/23/颜色分类/","content":"75.颜色分类题目描述：\n给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n必须在不使用库的sort函数的情况下解决这个问题。\n示例 1：\n输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2]\n示例 2：\n输入：nums = [2,0,1]输出：[0,1,2]\n提示：\nn == nums.length1 &lt;= n &lt;= 300nums[i] 为 0、1 或 2\n来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-colors\n思路：这个题较为简单，思路也非常明了，既然只有0，1，2三个数字，那我们直接把0放到数组前面，然后放1，再放2就行，遍历一趟来找到数字0，1出现的次数，然后再给数组赋值即可，时间复杂度o(n);\nc++代码：\nclass Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size();        int x = 0, y = 0;        for(int i = 0; i &lt; len; i++)&#123;            if(nums[i] == 0) x++;            else if(nums[i] == 1) y++;        &#125;        int i = 0;        len = len - x - y;        while(x)&#123;            nums[i++] = 0;            x--;        &#125;        while(y)&#123;            nums[i++] = 1;            y--;        &#125;        while(len)&#123;            nums[i++] = 2;            len--;        &#125;    &#125;&#125;;\n","categories":[],"tags":["LeetCode"]},{"title":"LeetCode 课程表 II","url":"http://yoursite.com/2020/03/23/LeetCode 课程表 II/","content":"名称：210. 课程表 II\n题目描述：现在你总共有 n 门课需要选，记为 0 到 n-1。\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]\n给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。\n可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。\n示例 1:输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。示例 2:输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n解题思路：首先是要判断是否可以完成全部的课程，很明显，我们应该用拓扑排序来做，那么数据结构我们就应该采用图（用map来存），再加上一个简单的bfs即可解出此题。c++代码class Solution &#123;public:    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        vector&lt;int&gt; result;        vector&lt;int&gt; fake;        vector&lt;int&gt; degree(numCourses , 0);        unordered_map&lt;int, vector&lt;int&gt;&gt; map;        for(vector&lt;int&gt; prerequisite : prerequisites) &#123;            map[prerequisite[1]].push_back(prerequisite[0]);            degree[prerequisite[0]]++;        &#125;        queue&lt;int&gt; q;&#x2F;&#x2F;用来做拓扑排序的队列        for(int i &#x3D; 0; i &lt; numCourses ; i++)&#123;            if(degree[i] &#x3D;&#x3D; 0)&#123;                q.push(i);            &#125;        &#125;        while(!q.empty())&#123;            int cur &#x3D; q.front();            result.push_back(cur);&#x2F;&#x2F;把每次的结果存起来，最终得到的就是顺序            q.pop();            for(int next : map[cur])&#123;                degree[next]--;                if(degree[next] &#x3D;&#x3D; 0)                    q.push(next);            &#125;        &#125;        return result.size() &#x3D;&#x3D; numCourses ? result : fake;&#x2F;&#x2F;fake是一个空的数组，如果找不到就输出空数组    &#125;&#125;;\n我的个人博客 amazingz6.github.io我的bilibili https://space.bilibili.com/66908429我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories\n","categories":[],"tags":[]},{"title":"动态查找（查找，插入及删除）","url":"http://yoursite.com/2019/12/12/动态查找（查找，插入及删除）/","content":"看代码啦#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef struct Zl//二叉查找表的结点&#123;    char data;//结点的值    int count;//结点出现的次数    Zl *lchild,*rchild;//左右孩子&#125;Zl;bool Search(Zl *T,char key,Zl *f,Zl* &amp;p)//查找操作&#123;    if(T==NULL)//此时找不到    &#123;        p=f;//记住最后访问的结点        return false;    &#125;    else if(T-&gt;data==key)//找到了    &#123;        p=T;//记录找到的结点        return true;    &#125;    else if(T-&gt;data&gt;key)//如果目标值小于当前值则到左子树进行查找    &#123;        return Search(T-&gt;lchild,key,T,p);    &#125;    else//大于则到右子树进行查找    &#123;        return Search(T-&gt;rchild,key,T,p);    &#125;&#125;bool Insert(Zl* &amp;T,char elem)//插入操作，也是建立二叉查找树的操作&#123;    Zl *p,*f;//p用来记住要找的结点，f指向当前节点的双亲结点    p=NULL;    f=NULL;    if(Search(T,elem,f,p)==true)//找到了    &#123;        p-&gt;count++;//个数加一        return false;    &#125;    else//没找到则插入    &#123;        Zl *temp;        temp=new Zl;        temp-&gt;data=elem;        temp-&gt;lchild=temp-&gt;rchild=NULL;        temp-&gt;count=1;        if(!p) T=temp;//数为空时直接将值赋给根节点        else if(elem&lt;p-&gt;data)//小于时则插入到左子树        &#123;            p-&gt;lchild=temp;        &#125;        else//大于时则插入到右子树        &#123;            p-&gt;rchild=temp;        &#125;        return true;    &#125;&#125;bool Delete(Zl* &amp;p)//删除p指针指向的结点&#123;    Zl* q;    if(p-&gt;lchild==NULL&amp;&amp;p-&gt;rchild==NULL)//既没有左子树也没有右子树时    &#123;        q=p;        p=NULL;        free(q);    &#125;    else if(p-&gt;lchild==NULL)//只有右子树时    &#123;        q=p;        p=p-&gt;rchild;//直接将p结点的右子树接到p结点的位置        free(q);    &#125;    else if(p-&gt;rchild==NULL)//只有左子树时    &#123;        q=p;        p=p-&gt;lchild;//直接将p结点的左子树接到p结点的位置        free(q);    &#125;    else//既有左子树也有右子树时    &#123;        q=p;        Zl *temp;        temp=p-&gt;lchild;        while(temp-&gt;rchild)//找到左子树中最右的结点，即中序遍历序列中上一个访问的结点        &#123;            q=temp;            temp=temp-&gt;rchild;        &#125;        p-&gt;data=temp-&gt;data;//将根节点置为找到的结点，然后删除找到的结点，该节点一定没有右子树        if(p!=q)            q-&gt;rchild=temp-&gt;lchild;//将删除结点的左子树接到他的双亲结点的右子树上        else//p=q时，说明p的左子树无右孩子，直接接上即可            p-&gt;lchild=temp-&gt;lchild;        free(temp);    &#125;    return true;&#125;bool DeleteBST(Zl* &amp;T,char key)//删除树中所有等于key的结点&#123;    if(!T) return false;    else    &#123;        if(T-&gt;data==key) return Delete(T);        else if(T-&gt;data&gt;key) return DeleteBST(T-&gt;lchild,key);        else return DeleteBST(T-&gt;rchild,key);    &#125;&#125;void MidOrderTraverse(Zl *p)//中序遍历输出&#123;    if(p!=NULL)    &#123;        MidOrderTraverse(p-&gt;lchild);        cout&lt;&lt;&#x27;[&#x27;&lt;&lt;p-&gt;data&lt;&lt;&#x27;:&#x27;&lt;&lt;p-&gt;count&lt;&lt;&#x27;]&#x27;&lt;&lt;endl;        MidOrderTraverse(p-&gt;rchild);    &#125;&#125;void XainOrderTraverse(Zl *p)//先序遍历输出&#123;    if(p!=NULL)    &#123;        cout&lt;&lt;&#x27;[&#x27;&lt;&lt;p-&gt;data&lt;&lt;&#x27;:&#x27;&lt;&lt;p-&gt;count&lt;&lt;&#x27;]&#x27;&lt;&lt;endl;        MidOrderTraverse(p-&gt;lchild);        MidOrderTraverse(p-&gt;rchild);    &#125;&#125;void HouOrderTraverse(Zl *p)//后序遍历输出&#123;    if(p!=NULL)    &#123;        MidOrderTraverse(p-&gt;lchild);        MidOrderTraverse(p-&gt;rchild);        cout&lt;&lt;&#x27;[&#x27;&lt;&lt;p-&gt;data&lt;&lt;&#x27;:&#x27;&lt;&lt;p-&gt;count&lt;&lt;&#x27;]&#x27;&lt;&lt;endl;    &#125;&#125;void Clean(Zl *first)//释放二叉查找树&#123;    if(first!=NULL)    &#123;        free(first);        Clean(first-&gt;lchild);        Clean(first-&gt;rchild);    &#125;&#125;int main()&#123;    Zl *T;    T=NULL;    char s[100];    cout&lt;&lt;&quot;请输入待统计的内容&quot;&lt;&lt;endl;    gets(s);//用gets接收来接收空格    for(int i=0;i&lt;strlen(s);i++)    &#123;        Insert(T,s[i]);    &#125;    DeleteBST(T,&#x27; &#x27;);    cout&lt;&lt;&quot;1.前序遍历输出&quot;&lt;&lt;endl;    cout&lt;&lt;&quot;2.中序遍历输出&quot;&lt;&lt;endl;    cout&lt;&lt;&quot;3.后序遍历输出&quot;&lt;&lt;endl;    cout&lt;&lt;&quot;0.退出&quot;&lt;&lt;endl;    cout&lt;&lt;&quot;请选择菜单项：&quot;&lt;&lt;endl;    int a;    while(1)    &#123;        cin&gt;&gt;a;        if(a==1)            XainOrderTraverse(T);        else if(a==2)            MidOrderTraverse(T);        else if(a==3)            HouOrderTraverse(T);        else            break;    &#125;    Clean(T);    return 0;&#125;测试数据：Every man loves what he is good at.运行结果:\n我的个人博客 amazingz6.github.io我的bilibili https://space.bilibili.com/66908429我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories\n","categories":[],"tags":[]},{"title":"二叉树的先序创建及遍历（包含层次遍历）和静态链表储存结构","url":"http://yoursite.com/2019/12/01/二叉树的先序创建及遍历（包含层次遍历）和静态链表储存结构/","content":"直接上代码（有注释）：#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;queue&gt;using namespace std;int x=1;//节点编号typedef struct Zl//二叉树的节点&#123;    char data;//数据域    struct Zl *lchild,*rchild;//指向左子树和右子树的指针    int index;//每个节点的编号&#125;Zl;typedef struct Static//静态链表的结点&#123;\tchar data;\t//数据域\tint lchild;  //指向左子树的指针域\tint rchild;  //指向右子树的指针域&#125;Static;Zl* PreOrderInitBTree()//先序建立二叉树&#123;\tZl *T;\tchar temp;\tcin&gt;&gt;temp;//由键盘输入结点数据域的值\tif(temp ==&#x27;0&#x27;)  //若某一节点为叶子结点，则其左右子树均为NULL，0表示建空树\t    T=NULL; \telse\t&#123;\t\tT=new Zl;\t\tT-&gt;data=temp;\t\tT-&gt;index=x++;\t\tT-&gt;lchild=PreOrderInitBTree();//递归创建其左子树\t\tT-&gt;rchild=PreOrderInitBTree();//递归创建其右子树\t&#125;\treturn T;                              //返回根节点&#125;void PreOrderTraverse(Zl *first)//先序遍历及输出二叉树&#123;    if(first!=NULL)    &#123;        cout&lt;&lt;first-&gt;data;//先输出结点值        PreOrderTraverse(first-&gt;lchild);        PreOrderTraverse(first-&gt;rchild);    &#125;&#125;void MidOrderTraverse(Zl *first)//中序遍历并输出二叉树&#123;    if(first!=NULL)    &#123;        MidOrderTraverse(first-&gt;lchild);        cout&lt;&lt;first-&gt;data;//先遍历完左子树再输出结点值        MidOrderTraverse(first-&gt;rchild);    &#125;&#125;void cengciTraverse(Zl *p)//层次遍历二叉树&#123;    queue&lt;Zl&gt; qe;//用队列来存放结点    qe.push(*p);    while(qe.empty()==false)//只要结点不为空就继续    &#123;        Zl temp=qe.front();//将将要出队的结点值储存在temp中        qe.pop();        if(temp.lchild!=NULL)            qe.push(*temp.lchild);//左孩子入队        if(temp.rchild!=NULL)            qe.push(*temp.rchild);//右孩子入队，按照先左后右的顺序入队，确保出队顺序        cout&lt;&lt;temp.data;//输出结点值    &#125;&#125;void Scopy(Static *s,Zl *p)//将动态二叉链表转化为静态链表&#123;    s[p-&gt;index].data=p-&gt;data;//数据同步过来    if(p-&gt;lchild==NULL)//左孩子为空时        s[p-&gt;index].lchild=0;    else    &#123;        s[p-&gt;index].lchild=p-&gt;lchild-&gt;index;//同步左孩子信息        Scopy(s,p-&gt;lchild);//递归同步左子树    &#125;    if(p-&gt;rchild==NULL)//左孩子为空时        s[p-&gt;index].rchild=0;    else    &#123;        s[p-&gt;index].rchild=p-&gt;rchild-&gt;index;//同步右孩子信息        Scopy(s,p-&gt;rchild);//递归同步右子树    &#125;&#125;void Destory(Zl *p)//删除单个结点&#123;    free(p);&#125;void Clean(Zl *first)//整表删除&#123;    if(first!=NULL)    &#123;        Clean(first-&gt;lchild);        Clean(first-&gt;rchild);    &#125;    free(first);&#125;int main()&#123;    Zl *first;    cout&lt;&lt;&quot;请按先序顺序输入二叉树序列，0代表空&quot;&lt;&lt;endl;    first=PreOrderInitBTree();    cout&lt;&lt;&quot;先序输出：&quot;&lt;&lt;endl;    PreOrderTraverse(first);//先序遍历输出    cout&lt;&lt;endl;    cout&lt;&lt;&quot;中序输出&quot;&lt;&lt;endl;    MidOrderTraverse(first);//中序遍历输出    cout&lt;&lt;endl;    cout&lt;&lt;&quot;层次遍历输出&quot;&lt;&lt;endl;    cengciTraverse(first);//层次遍历输出    cout&lt;&lt;endl;    Static s[20];    Scopy(s,first);    cout&lt;&lt;&quot;静态链表输出：&quot;&lt;&lt;endl;    for(int i=1;i&lt;x;i++)//输出静态链表    &#123;        cout&lt;&lt;&quot;下标为:&quot;&lt;&lt;i&lt;&lt;&quot; 数据:&quot;&lt;&lt;s[i].data&lt;&lt;&quot; 左孩子下标:&quot;&lt;&lt;s[i].lchild&lt;&lt;&quot; 右孩子下标:&quot;&lt;&lt;s[i].rchild&lt;&lt;endl;//依次输出结点值及左子树编号和右子树编号    &#125;    Clean(first);    return 0;&#125;这棵二叉树的逻辑结构为：程序运行结果：\n我的个人博客 amazingz6.github.io我的bilibili https://space.bilibili.com/66908429我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories\n","categories":[],"tags":[]},{"title":"一元二次多项式的相加","url":"http://yoursite.com/2019/11/17/一元二次多项式的相加/","content":"这次我们话不多说，直接上代码，看代码注释即可\n#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;using namespace std;typedef struct Zlnb&#123;    double x; //系数    int y;  //指数    struct Zlnb *next; //指针域&#125;Zl;//节点名称void PrintPoly(Zl *s)//打印单个项&#123;    if(s-&gt;y==0)//指数等于零时，直接输出系数    &#123;        cout&lt;&lt;s-&gt;x;    &#125;    else if(s-&gt;x==1)//系数为1时，1省略    &#123;        if(s-&gt;y==1)//指数为1时省略不写            cout&lt;&lt;&quot;x&quot;;        else            cout&lt;&lt;&quot;x^&quot;&lt;&lt;s-&gt;y;    &#125;    else if(s-&gt;x==-1)//系数为1时，-1省略    &#123;        if(s-&gt;y==1)//指数为1时省略不写            cout&lt;&lt;&quot;-x&quot;;        else            cout&lt;&lt;&quot;-x^&quot;&lt;&lt;s-&gt;y;    &#125;    else    &#123;        if(s-&gt;y==1)//指数为1时省略不写            cout&lt;&lt;s-&gt;x&lt;&lt;&quot;x&quot;;        else            cout&lt;&lt;s-&gt;x&lt;&lt;&quot;x^&quot;&lt;&lt;s-&gt;y;    &#125;&#125;void PrintPolyn(Zl *first)//利用PrintPoly打印整个多项式&#123;    Zl *temp=first-&gt;next;//表头没有数据，表头的下一个才是多项式的第一个项    while(temp-&gt;next!=NULL)//遍历，从第一个打印到倒数第二个    &#123;        PrintPoly(temp);        temp=temp-&gt;next;        if(temp-&gt;x&gt;0)            cout&lt;&lt;&quot;+&quot;;//只有一个项时此循环不执行，所以直接打印加号即可    &#125;    PrintPoly(temp);//打印最后一个    cout&lt;&lt;endl;&#125;void ListInsert(Zl *first,Zl *s)//插入，将s节点插入到最后&#123;    Zl *temp=first;    while(temp-&gt;next!=NULL)//循环找到最后一个节点        temp=temp-&gt;next;    temp-&gt;next=s;//插入s    s-&gt;next=NULL;&#125;Zl* InputData(int k)//输入函数，采用先输入系数后输入次数的方法，k代表是第几个多项式&#123;    Zl *first=new Zl;//创建多项式链表的头指针    first-&gt;next=NULL;//头指针初始化    int a;    int com[100];    printf(&quot;请输入第%d个多项式的项数：&quot;,k);    cin&gt;&gt;a;//接受多项式的项数    if(a&lt;=0)//确保项数大于0    &#123;        cout&lt;&lt;&quot;系数输入错误，请关闭程序重新输入&quot;&lt;&lt;endl;        return 0;    &#125;    for(int i=1;i&lt;=a;i++)//循环接收多项式的每个项    &#123;        Zl *p=new Zl;//用p存下即将读取的数据        p-&gt;next=NULL;        double m;        int n;        printf(&quot;请输入第%d项的系数：&quot;,i);        cin&gt;&gt;m;        if(!m)//系数不能等于0        &#123;            cout&lt;&lt;&quot;系数输入错误，请关闭程序重新输入&quot;&lt;&lt;endl;            return 0;        &#125;        printf(&quot;请输入第%d项的次数：&quot;,i);        cin&gt;&gt;n;        com[i]=n;        for(int j=1;j&lt;i;j++)//循环遍历是否有重复项出现            if(n==com[j])            &#123;                cout&lt;&lt;&quot;次数输入重复，请关闭程序重新输入&quot;&lt;&lt;endl;                return 0;            &#125;        p-&gt;x=m;//赋值        p-&gt;y=n;        ListInsert(first,p);//将p插入多项式中        cout&lt;&lt;endl;    &#125;    printf(&quot;该多项式可表示为：&quot;);    PrintPolyn(first);//打印多项式    cout&lt;&lt;endl;    return first;//返回多项式的首地址&#125;Zl* AddPolyn(Zl *a,Zl*b)//两个多项式相加的函数&#123;    Zl *first=new Zl;//创建一个新的链表来存两多项式相加得到的结果    first-&gt;next=NULL;    Zl *m=a-&gt;next;//注意，这里表头没有存放数据，表头的下一个才存放的是多项式第一个项    Zl *n=b-&gt;next;    while(m!=NULL&amp;&amp;n!=NULL)//有一个表空了就跳出循环    &#123;        Zl *temp=new Zl;//和上面的p一样，暂存得到的数据        temp-&gt;next=NULL;        int num=m-&gt;y-n-&gt;y;//判断指数的大小        if(num&lt;0)//m的指数小于n        &#123;            temp-&gt;x=m-&gt;x;            temp-&gt;y=m-&gt;y;            ListInsert(first,temp);//因为m指数小于n，将m的当前项复制过来插入结果链表            m=m-&gt;next;//指针后移        &#125;        else if(num&gt;0)//m的指数大于n        &#123;            temp-&gt;x=n-&gt;x;            temp-&gt;y=n-&gt;y;            ListInsert(first,temp);//因为m指数大于n，将n的当前项复制过来插入结果链表            n=n-&gt;next;//指针后移        &#125;        else//m的指数等于n        &#123;//            double ans=m-&gt;x+n-&gt;x;            if(ans!=0)&#123;//系数和不等于0时系数相加作为新的系数插入结果链表中                temp-&gt;x=ans;                temp-&gt;y=m-&gt;y;                ListInsert(first,temp);            &#125;//系数和不等于零时直接指针后移即可，由于两种情况都会后移，所以可以合并            m=m-&gt;next;            n=n-&gt;next;        &#125;    &#125;    Zl *templist=new Zl;//创建一个临时链表来将存放可能的剩下的项    templist-&gt;next=NULL;    if(m!=NULL)//当m链表还有剩余项时    &#123;        Zl *p=m;        while(p!=NULL)//循环遍历剩下的项        &#123;            Zl *temp=new Zl;            temp-&gt;x=p-&gt;x;            temp-&gt;y=p-&gt;y;            temp-&gt;next=NULL;//用temp暂存当前项            ListInsert(templist,temp);//插入temp            p=p-&gt;next;        &#125;        Zl *temp=first;        while(temp-&gt;next!=NULL)//循环找到结果链表的最后一项            temp=temp-&gt;next;        temp-&gt;next=templist-&gt;next;//直接将临时链表接在结果链表后面即可    &#125;    if(n!=NULL)//当n链表还有剩余项时，步骤与上面的情况一样    &#123;        Zl *p=n;        while(p!=NULL)        &#123;            Zl *temp=new Zl;            temp-&gt;x=p-&gt;x;            temp-&gt;y=p-&gt;y;            temp-&gt;next=NULL;            ListInsert(templist,temp);            p=p-&gt;next;        &#125;        Zl *temp=first;        while(temp-&gt;next!=NULL)            temp=temp-&gt;next;        temp-&gt;next=templist-&gt;next;    &#125;    return first;//返回结果链表的头指针&#125;void FreePolyn(Zl *s)//释空间&#123;    Zl *p=s;    while(s!=NULL)//遍历链表一个一个释放空间    &#123;        s=s-&gt;next;        free(p);        p=s;    &#125;&#125;int main()&#123;    cout&lt;&lt;&quot;/*注意:系数为浮点类型，指数为整数（可为负）类型&quot;&lt;&lt;endl;    cout&lt;&lt;&quot;请按指数从小到大的顺序输入多项式。*/&quot;&lt;&lt;endl;    Zl *a;//用来存放多项式1    Zl *b;//用来存放多项式2    Zl *c;//用来存放结果多项式    a=InputData(1);//输入多项式1    b=InputData(2);//输入多项式2    c=AddPolyn(a,b);//相加    cout&lt;&lt;&quot;多项式之和为：&quot;;    PrintPolyn(c);//打印结果    FreePolyn(a);//依次释放链表空间    FreePolyn(b);    FreePolyn(c);    return 0;&#125;\n运行测试和结果：\n我的个人博客 amazingz6.github.io我的bilibili https://space.bilibili.com/66908429我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories\n","categories":[],"tags":[]},{"title":"串的模式匹配算法","url":"http://yoursite.com/2019/10/27/串的模式匹配算法/","content":"1.模式匹配简单算法Index(S,T,pos);初始条件：串S和T存在，T是非空串，1≤pos≤StrLength(S)。操作结果：若主串S中存在和串T值相同的子串返回它在主串S中第pos个字符之后第一次出现的位置；否则函数值为0。int Index (String S, String T, int pos) &#123; // T为非空串。若主串S中第pos个字符之后存在与 T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0  if (pos &gt; 0) &#123;    n = StrLength(S);  m = StrLength(T);  i = pos;    while ( i &lt;= n-m+1) &#123;        SubString (sub, S, i, m);//表示在S串中取从第i位置开始的m长度字串并存在sub里        if (StrCompare(sub,T) != 0)   ++i ;//比较，不成功则往后移        else return i ;    &#125; // while  &#125; // if  return 0;          // S中不存在与T相等的子串&#125; // Index如果我们不采用串的基本操作的话，还可以这样写int Index(SString S, SString T, int pos) &#123;// 返回子串T在主串S中第pos个字符之后的位置。若不存在，// 则函数值为0。其中，T非空，1≤pos≤StrLength(S)。　i = pos;   j = 1;    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123;      if (S[i] == T[j]) &#123; ++i;  ++j; &#125;   // 继续比较后继字符      else &#123; i = i-j+2;   j = 1; &#125;     // 指针后退重新开始匹配    &#125;   if (j &gt; T[0])  return  i-T[0];   else return 0;&#125; // Index将S串于T串一个字符一个字符的进行比较，一旦不同则将i退到开始上一次开始比较的位置的下一个，j直接退到T串的串首即可设上次一比较在S串中的起始位置为x则  x+j-1=i所以x=i-j+1则下一个位置为i-j+2，所以是i=i-j+2匹配成功，同样返回首位置，否则返回零上述算法时间复杂度最坏都达到了O(m*n);\n2.模式匹配的改进算法(KMP算法)KMP算法的改进在于：每当一趟匹配过程中出现字符比较不相等时，不需回溯i指针，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较，i不动，j向前移举个例子比较s=‘acabaabaabcacaabc’  t=‘abaabc’第一次比较时比较到第二个发现不同，于是将j指针移回a　　　\n接着进行比较，比较到t中的c时发现不一样，但此前已经比较过两次ac,无需再比一次，所以将j指针移到t中的第三个a即可\n\n这样就比完了，比上一种方法要少比很多次，效率提高了不少在用这种方法时，我们需要知道每次比较不一样时j指针需要回到t串中的那个位置，所以我们用next数组来存放回溯的位置，就串t=‘abaabc’来说，next[j]={0,1,1,2,2,3};j从1开始即\n算法实现如下由于我们模式串的数据是从第一个开始存放，为了不浪费空间，这里把模式串的长度放在t[0]里面int Index_KMP(SString S, SString T, int pos) &#123;     //  1≤pos≤StrLength(S)     i = pos;   j = 1;     while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123;         if (j == 0 || S[i] == T[j]) &#123; ++i;  ++j; &#125;                                               // 继续比较后继字符        else  j = next[j];         // 模式串向右移动     &#125;    if (j &gt; T[0])  return  i-T[0];    // 匹配成功    else return 0;&#125; // Index_KMPnext函数\nvoid get_next(SString &amp;T, int &amp;next[] ) &#123;     // 求模式串T的next函数值并存入数组next     i = 1;   next[1] = 0;   j = 0;      while (i &lt; T[0]) &#123;           if (j == 0 || T[i] == T[j])                 &#123;++i;  ++j; next[i] = j; &#125;           else  j = next[j];      &#125;    &#125; // get_next\n此外，如果不匹配时发现前面已经比较过的，和将要比较的那个是完全一样的话，就没有比下去的必要了，例如模式串为 aaaab时，如果j=3发现不同，按上一种方法，则应移到j=2经行比较，但j=2时也是a，再比较就相当于多比了一次，这样就有了改进的空间。代码如下：\nvoid get_nextval(SString &amp;T, int &amp;nextval[]) &#123;      i = 1;   nextval[1] = 0;   j = 0;      while (i &lt; T[0]) &#123;          if (j == 0 || T[i] == T[j]) &#123;              ++i;  ++j;              if (T[i] != T[j])  next[i] = j;              else  nextval[i] = nextval[j];         &#125;        else  j = nextval[j];     &#125;  &#125; // get_nextval\n我的个人博客 amazingz6.github.io我的bilibili https://space.bilibili.com/66908429我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories\n","categories":[],"tags":[]},{"title":"JAVAString类常用方法","url":"http://yoursite.com/2019/09/18/JAVAString类常用方法/","content":"1.创建新StringString concat(String s);&#x2F;&#x2F;返回一个新串，在原串后附加上s。String replace(String old, String new);&#x2F;&#x2F;返回一个新串，将原串中出现的old替换成new。String substring(int start, int end);&#x2F;&#x2F;返回一个新串，它是原串中从start到end的一部分。String toLowerCase();&#x2F;&#x2F;返回一个新串，它将原串中的大写字母变成小写。String toUpperCase();&#x2F;&#x2F;返回一个新串，它将原串中的小写字母变成大写。\n2.查找方法boolean endsWith(String s);&#x2F;&#x2F;如原串以s串为结尾，则返回true。boolean startsWith(String s);&#x2F;&#x2F;如原串以s串为开始，则返回true。int indexOf(String s);&#x2F;&#x2F;返回串中第一次出现s串的序号值。int indexOf(String s, int offset);&#x2F;&#x2F;返回串中从offset开始查找，第一次出现s串的序号值。\n3.比较方法boolean equals(String s);&#x2F;&#x2F;如果原串与s串相等，则返回true。boolean equalsIgnoreCase(String s);&#x2F;&#x2F;如果在忽略大小写的情况下，原串与s串相等，则返回true。int  compareTo(String s);&#x2F;&#x2F;进行字典序比较，如果原串小于s串则返回负数；如果原串大于s串则返回正数；如果原串等于s串则返回零。\n4.其它方法str.split(&quot;,&quot;);&#x2F;&#x2F;根据字符来拆分字符串，当我们需要以‘|’、‘：’、‘+’、‘.’、‘^’等特殊字符作为拆分条件的话，则需要加上 \\\\ 转义字符charAt(int index)&#x2F;&#x2F;返回index处的字符。int length()&#x2F;&#x2F;返回串的长度。str.trim();&#x2F;&#x2F;裁除首、尾空格符str.contains(&quot;&quot;);&#x2F;&#x2F;是否包含 &quot;&quot;\n","categories":[],"tags":[]},{"title":"JAVA基础知识","url":"http://yoursite.com/2019/09/17/JAVA基础知识/","content":"本人刚学JAVA，写个博客来给自己巩固一下基本知识 (=・ω・=)\n1.JAVA数据输出格式的控制String.format.(&quot;格式串&quot;，数值数据）//方法一System.out.print(&quot;格式串&quot;，数值数据) //方法二\n2.用float时数后要加Ffloat a=3.4F;\n3.数字不能自动转化为Boolean4.字符检测的方法char ch=&#x27;a&#x27;;Character.isLetter(ch) -- ch是否是字母Character.isDigit(ch)  -- ch是否是数字Character.isLetterOrDigit(ch) -- ch是否是字母或数字Character.isWhitespace(ch) -- ch是否是空格Character.isLowerCase(ch) -- ch是否是小写字母Character.isUpperCase(ch) -- ch是否是大写字母\n5.自定义符号常量加finalfinal double PI=3.14159;\n6.在方法外定义的变量会自动初始化7.String加其他类型变量时会将其他类型转化为字符类型8.字符串转数值方法1：int i = Integer.parseInt(&quot;123&quot;);       (常用)double d = Double.parseDouble(&quot;1.23&quot;);方法2：int i =Integer.valueOf(&quot;123&quot;).intValue(); \n9.数值转字符串 方法1： String s=String.valueOf(value);  其中value为任一种数字类型。\n方法2：String s = Integer.toString(123);方法3：最直接String s = &quot;&quot; + value;  其中value为任意一种数字类型。\n10.字符数组转字符串  char[ ] c=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;String str=new String(c);\n11.字符串转字符数组String str=&quot;abc&quot;;char[ ]  c=str.toCharArray(); \n12.”==”和equals的区别String s1=&quot;abc&quot;;  //方法以String s2=&quot;abc&quot;;String s3=new String(&quot;abc&quot;); //方法二String s4=new String(&quot;abc&quot;);System.out.println(s1==s2); System.out.println(s1.equals(s2));System.out.println(s3==s4);System.out.println(s3.equals(s4));            \n得到的结果为true,true,false,true.方法一属于常量式创建，会存放一个在一个叫String pool 的地方，再次创建时会直接引用存在的相同变量而方法二属于对象式创建，是运行时在Heap内存里面创建对象，每new一次都一定会创建对象而“==”是比较两者的地址是否一样，所以第三个为falseequals是比较变量是否一样。\n13.%也能用于浮点型变量14.类型转换当没有信息丢失时，变量可被自动升级为一个较长的形式（如：int至long的升级）long bigval = 6;  // 6 is an int type, OKint smallval = 99L;  // 99L is a long, error double z = 12.414F;  // 12.414F is float, OKfloat z1 = 12.414;  // 12.414 is double, error//但升级也可能会导致出错short  a，b，ca=1；b=2；c= a+b；//上述程序会因为在操作short之前提升每个short至int而出错。//然而，如果c被声明为一个int，或按如下操作进行类型转换：c = (short)(a+b);//则上述代码将会成功通过我的个人博客 amazingz6.github.io我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories我的bilibili https://space.bilibili.com/66908429\n","categories":[],"tags":["JAVA基础知识"]},{"title":"计算三重积分的四种方法","url":"http://yoursite.com/2019/09/11/计算三重积分的四种方法/","content":"以后可能会经常使用，在这里总结一下\n先一后二法$\\iiint _{\\Omega }f\\left( x,y,z\\right) dv=\\int ^{b}_{a}dx\\int ^{y_{2}\\left( x\\right) }_{y_{1}\\left( x\\right) }dy\\int ^{z_{2}\\left( x,y\\right) }_{z_{1}\\left( x,y\\right) }f\\left( x,y,z\\right) dz$\n先二后一法$\\begin{aligned}\\iiint _{\\Omega }f\\left( x,y,z\\right) dv=\\int ^{b}_{a}dz\\iint _{Dz}f\\left( x,y,z\\right) dxdy\\end{aligned}$\n利用柱面坐标计算$\\begin{cases}x=\\rho \\cos \\theta \\\\ y=\\rho \\sin \\theta \\\\ z=z\\end{cases}\\iiint _{\\Omega }f\\left( x,y,z\\right) dv=\\begin{aligned}\\iiint _{\\Omega }f\\left( \\rho \\cos \\theta ,\\rho \\sin \\theta ,z\\right) \\rho d\\rho d\\theta dz\\end{aligned}$\n利用球面坐标计算$\\begin{cases}x=r\\sin \\varphi \\cos \\theta \\\\ y=r\\sin \\varphi \\sin \\theta \\\\ z=r\\cos \\varphi \\end{cases}\\begin{aligned}\\iiint _{\\Omega }f\\left( x,y,z\\right) dv=\\iiint _{\\Omega }f\\left( r\\sin \\varphi \\cos \\theta ,r\\sin \\varphi \\sin \\theta ,r\\cos y\\right) r^{2}\\sin \\varphi drdyd\\theta \\end{aligned}$\n","categories":[],"tags":[]},{"title":"Eclipse的安装,HelloWorld的实现以及jdk的下载与环境配置","url":"http://yoursite.com/2019/09/05/Eclipse的安装-HelloWorld的实现以及jdk的下载与环境配置/","content":"上了第一节JAVA课后，老师然我们自己下去安装Eclipse以及JAVA的jdk，也是费了我一番功夫，在这里简单总结一下，希望能帮助到大家\n1.Eclipse的下载与安装直接百度搜索Eclipse，下面第一个就是官网，进入官网我们选择downlaoad packages然后选择对应的要下载的版本，我这里选的是Windows\n直接下载的话速度可能会非常慢，可以把镜像改成国内的，会快很多最后按默认安装即可\n2.HelloWorld的实现打开eclipse后选择New-&gt;Project-&gt;java project在project name输入HelloWorld在Module name也输入HelloWorld然后在左边的视图里找到src，右键创建一个package，接着在你创建的package上右键创建一个class ，class名为HelloWorld然后写上代码即可\n如图所示，点击右上角运行即可，下方即会出现HelloWorld\n3.jdk的下载与jdk的配置百度jdk第一项便是oracle官网进入后下载对应的版本即可!xxx我下的是最后一项,windows的zip然后经行环境的配置打开系统的环境变量首先新建一个系统变量JAVA_HOME变量值为你的jdk路径，注意是你自己的路径\n接着再新建一个系统变量CLASSPATH变量值为  ;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tool.jar复制过去就好\n接着再系统变量的path里加上%JAVA_HOME%\\bin与%CLASSPATH%即可\n至此环境就配好了我们可以在命令行里分别输入java 与 javac 来查看是否配置成功如果成功则应出现相应的内容\n我的个人博客 amazingz6.github.io我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories我的bilibili https://space.bilibili.com/66908429\n","categories":[],"tags":[]},{"title":"树莓派小车基本功能的实现","url":"http://yoursite.com/2019/08/05/树莓派小车基本功能的实现/","content":"在2019年暑假，大一的我参加了学校组织的为期15天的实训，实训内容就是树莓派小车的基本功能的实现，包括移动，拍照，录像等。下面我将对本次实训经行一个简单的回顾\n1.小车的组装首先我们需要一下材料树莓派，小车零件，杜邦线，电池盒，L298N电机驱动模块，TF卡/SD卡然后按照电路图将小车的零部件一个一个组装起来即可唯一需要注意的是引脚的对应如图所示，程序里的引脚的标号为黄色框里的编号，横向对应红色框里的物理接口\n下图为组装好的小车\n\n2.SOCKET编程那么要如何实现电脑端与小车的通信呢，这时候就需要用到socket编程了，它可以通过IP地址实现两地之间的通信\n\n套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合\n\n首先我们要实现最基本的本地通信下面附上最基本的本地通信的代码客户端：#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;WINSOCK2.H&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)using namespace std;int initser(int port,char*ip,int* psockFd)&#123;    WORD sockVersion = MAKEWORD(2, 2);    WSADATA wsaData;    if (WSAStartup(sockVersion, &amp;wsaData) != 0)    &#123;        return 0;    &#125;    int sockFd = socket(AF_INET, SOCK_STREAM, 0);    if (sockFd &lt; 0)    &#123;        printf(&quot;socket error\\n&quot;);        return -1;    &#125;    else    printf(&quot;create socket success\\n&quot;);    struct sockaddr_in serAddr;    memset(&amp;serAddr, 0, sizeof(serAddr));    serAddr.sin_family = AF_INET;    serAddr.sin_port = htons(port);    serAddr.sin_addr.S_un.S_addr = inet_addr(ip);    int res = connect(sockFd, (struct sockaddr*) &amp; serAddr, sizeof(serAddr));    if (sockFd &lt; 0)    &#123;        printf(&quot;connect error\\n&quot;);        return -1;    &#125;    else    printf(&quot;connect success\\n&quot;);    *psockFd = sockFd;&#125;int main()&#123;    int sockFd = 0;    char ip[100] = &#123; &quot;192.168.101.63&quot; &#125;;//这里填自己本机所使用的IP地址    initser(5000, ip, &amp;sockFd);//端口的数字可以自己决定，不过要保证客户端与服务器一致且一般较大    char buf[100] = &#123; 0 &#125;;    gets_s(buf);    int res = send(sockFd, buf, sizeof(buf), 0);//发送信息    if (res &lt; 0)    &#123;        printf(&quot;send err\\n&quot;);       return -1;    &#125;    printf(&quot;send data success [%s]\\n&quot;, buf);    closesocket(sockFd);    return 0;&#125;\n服务器：#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;WinSock2.h&gt;using namespace std;//使用ws2_32.lib静态库#pragma comment(lib,&quot;ws2_32.lib&quot;)int initSer(int port, int* psockFd)&#123;    WORD sockVersion = MAKEWORD(2, 2);    WSADATA wsadata;    if (WSAStartup(sockVersion, &amp;wsadata) != 0)    &#123;        return 0;    &#125;    int sockFd = socket(AF_INET, SOCK_STREAM, 0);    if (sockFd &lt; 0)    &#123;        cout &lt;&lt; &quot;socket fail!&quot; &lt;&lt; endl;        return -1;    &#125;    else    cout &lt;&lt; &quot;socket success!&quot; &lt;&lt; endl;    struct sockaddr_in serAddr;    memset(&amp;serAddr, 0, sizeof(serAddr));    serAddr.sin_family = AF_INET;    serAddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//让操作系统指派IP，即目前使用的IP    serAddr.sin_port = htons(port);    int res = bind(sockFd, (struct sockaddr*) &amp; serAddr, sizeof(serAddr));    if (res &lt; 0)    &#123;        cout &lt;&lt; &quot;bind fail!&quot; &lt;&lt; endl;        return -1;    &#125;    else        cout &lt;&lt; &quot;bind success!&quot; &lt;&lt; endl;    res = listen(sockFd, 10);    if (res &lt; 0)    &#123;        cout &lt;&lt; &quot;listen fail!&quot; &lt;&lt; endl;        return -1;    &#125;    else    cout &lt;&lt; &quot;listen success!&quot; &lt;&lt; endl;    int newsockFd = accept(sockFd, NULL, NULL);    if (sockFd &lt; 0)    &#123;        cout &lt;&lt; &quot;accept fail!&quot; &lt;&lt; endl;    return -1;    &#125;    else    cout &lt;&lt; &quot;accept success!&quot; &lt;&lt; endl;    *psockFd = newsockFd;    return 0;&#125;int main()&#123;    int sockFd = 0;    initSer(5000, &amp;sockFd);//端口的数字可以自己决定，不过要保证客户端与服务器一致且一般较大    char buf[100] = &#123; 0 &#125;;    int res = recv(sockFd, buf, sizeof(buf), 0);//接收信息    if (res &lt; 0)    &#123;        printf(&quot;recv err\\n&quot;);        return -1;    &#125;    printf(&quot;recv data success [%s]\\n&quot;, buf);    closesocket(sockFd);    return 0;&#125;上面的代码虽然能实现通信，但是只能通信一次，就算加了while也只能按照一定的规律来通信，所以我们这里为了实现随发随收，就需要加上多线程只需将发送与接收写在两个不同的线程中即可下面附上代码\n客户端：#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;WINSOCK2.H&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)#define PORT 5000using namespace std;HANDLE hMutex = NULL;DWORD WINAPI Fun1(LPVOID lpparamter)&#123;\tint newsockFd = *(int*)lpparamter;\twhile (1)\t&#123;\t\tchar buf[100] = &#123; 0 &#125;;\t\tmemset(buf, &#x27;\\0&#x27;, sizeof(buf));\t\tint res = recv(newsockFd, buf, 100, 0);//接收\t\tif (res &lt; 0)\t\t&#123;\t\t\tcout &lt;&lt; &quot;recv fail!&quot; &lt;&lt; endl;\t\t\treturn -1;\t\t&#125;\t\telse\t\t\tprintf(&quot;receive message[%s]\\n&quot;, buf);\t&#125;\treturn 0L;&#125;DWORD WINAPI Fun2(LPVOID lpparamter)&#123;\tint newsockFd = *(int *)lpparamter;\twhile (1)\t&#123;\t\tchar buf[100] = &#123; 0 &#125;;\t\tgets_s(buf);\t\tint res = send(newsockFd, buf, sizeof(buf), 0);//发送\t\tif (res &lt; 0)\t\t&#123;\t\t\tprintf(&quot;send err\\n&quot;);\t\t\treturn -1;\t\t&#125;\t\tprintf(&quot;send success [%s]\\n&quot;, buf);\t&#125;\treturn 0L;&#125;int main()&#123;\tWORD sockVersion = MAKEWORD(2, 2);\tWSADATA wsaData;\tif (WSAStartup(sockVersion, &amp;wsaData) != 0)\t&#123;\t\treturn 0;\t&#125;\tint sockFd = socket(AF_INET, SOCK_STREAM, 0);\tif (sockFd &lt; 0)\t&#123;\t\tprintf(&quot;socket error\\n&quot;);\t\treturn -1;\t&#125;\telse\t    printf(&quot;create socket success\\n&quot;);\tstruct sockaddr_in serAddr;\tmemset(&amp;serAddr, 0, sizeof(serAddr));\tserAddr.sin_family = AF_INET;\tserAddr.sin_port = htons(PORT);\tserAddr.sin_addr.S_un.S_addr = inet_addr(&quot;172.16.13.62&quot;);\tint res = connect(sockFd, (struct sockaddr*) &amp; serAddr, sizeof(serAddr));\tif (sockFd &lt; 0)\t&#123;\t\tprintf(&quot;connect error\\n&quot;);\t\treturn -1;\t&#125;\telse \t    printf(&quot;connect success\\n&quot;);\t//创建线程\tHANDLE hand1 = CreateThread(NULL, 0, Fun2, &amp;sockFd , 0, NULL);\tHANDLE hand2 = CreateThread(NULL, 0, Fun1, &amp;sockFd , 0, NULL);\tWaitForSingleObject(hand1, INFINITE);        closesocket(sockFd);\treturn 0;&#125;\n服务器：\n#include &lt;iostream&gt;#include &lt;WinSock2.h&gt;using namespace std;#define PORT 5000//使用ws2_32.lib静态库#pragma comment(lib,&quot;ws2_32.lib&quot;)HANDLE hMutex = NULL;DWORD WINAPI Fun1(LPVOID lpparamter)&#123;\tint newsockFd = *(int*)lpparamter;\twhile(1)\t&#123;\t\tchar buf[100] = &#123; 0 &#125;;\t\tmemset(buf, &#x27;\\0&#x27;, sizeof(buf));\t\tint res = recv(newsockFd, buf, 100, 0);//接收\t\tif (res &lt; 0)\t\t&#123;\t\t\tcout &lt;&lt; &quot;recv fail!&quot; &lt;&lt; endl;\t\t\treturn -1;\t\t&#125;\t\telse\t\t\tprintf(&quot;receive message[%s]\\n&quot;, buf);\t&#125;\treturn 0L;&#125;DWORD WINAPI Fun2(LPVOID lpparamter)&#123;\tint newsockFd = *(int*)lpparamter;\twhile(1)\t&#123;\t\tchar buf[100] = &#123; 0 &#125;;\t\tgets_s(buf);\t\tint res = send(newsockFd, buf, sizeof(buf), 0);//发送\t\tif (res &lt; 0)\t\t&#123;\t\t\tprintf(&quot;send err\\n&quot;);\t\t\treturn -1;\t\t&#125;\t\tprintf(&quot;send success [%s]\\n&quot;, buf);\t&#125;\treturn 0L;&#125;int main()&#123;\t//windows下需要加载的SOCKET库\tWORD sockVersion = MAKEWORD(2, 2);\tWSADATA wsadata;\tif (WSAStartup(sockVersion, &amp;wsadata) != 0)\t&#123;\t\treturn 0;\t&#125;\tint sockFd = socket(AF_INET, SOCK_STREAM, 0);\tif (sockFd &lt; 0)\t&#123;\t\tcout &lt;&lt; &quot;socket fail!&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\telse\t\tcout &lt;&lt; &quot;socket success!&quot; &lt;&lt; endl;\tstruct sockaddr_in serAddr;\tmemset(&amp;serAddr, 0, sizeof(serAddr));\tserAddr.sin_family = AF_INET;\tserAddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);\tserAddr.sin_port = htons(PORT);\tint rec = bind(sockFd, (struct sockaddr*) &amp; serAddr, sizeof(serAddr));\tif (rec &lt; 0)\t&#123;\t\tcout &lt;&lt; &quot;bind fail!&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\telse\t\tcout &lt;&lt; &quot;bind success!&quot; &lt;&lt; endl;\trec = listen(sockFd, 10);\tif (rec &lt; 0)\t&#123;\t\tcout &lt;&lt; &quot;listen fail!&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\telse\t\tcout &lt;&lt; &quot;listen success!&quot; &lt;&lt; endl;\tint newsockFd = accept(sockFd, NULL, NULL);\tif (sockFd &lt; 0)\t&#123;\t\tcout &lt;&lt; &quot;accept fail!&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\telse\t\tcout &lt;&lt; &quot;accept success!&quot; &lt;&lt; endl;\t//创建线程\tHANDLE hand1 = CreateThread(NULL, 0, Fun1, &amp;newsockFd, 0, NULL);\tHANDLE hand2 = CreateThread(NULL, 0, Fun2, &amp;newsockFd, 0, NULL);\tWaitForSingleObject(hand1, INFINITE);\tclosesocket(newsockFd);\tclosesocket(sockFd);\treturn 0;&#125;\n至此就实现了实时的发送接收然后我们就可以尝试与小车进行通信了\n3.与小车连接我们首先需要与小车建立连接来将服务器端的代码送进去（这里也可以把小车作为客户端，一样可行，有兴趣的话可以自己去尝试）这里我们需要下面两个工具来连接小车https://pan.baidu.com/s/1f7WXga7jDd45v9jeusdQuA  提取码2w7m首先打开树莓派，连上WIFI然后打开下载好的Putty在hostname框输入自己本机的IP地址接着点击OPEN即可接着输入自己的登陆用户名及密码也可以在下面的 Saved Sessions里面保存自己的IP地址，方便使用到这里其实就连上树莓派了然后可以用FileZilla来经行数据传输在文件-&gt;站点管理器一栏输入自己的IP以及用户名密码然后连接即可这时就可以对树莓派的内的文件经行操作了接下来就可以尝试将服务器文件放到树莓派之中需要注意的是小车内部是linux环境所以需要做一些修改首先把下面这段删掉，因为这是WINDOWS下需要加载的库\n       WORD sockVersion &#x3D; MAKEWORD(2, 2);WSADATA wsadata;\n还有就是serAddr.sin_addr.S_un.S_addr &#x3D; htonl(INADDR_ANY);改成serAddr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);\n然后就是头文件的修改直接百度找到对应的替换的头文件即可或者直接用这个#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;stdio.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;netinet&#x2F;in.h&gt;#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;#include &lt;opencv2&#x2F;highgui&#x2F;highgui.hpp&gt;#include &lt;opencv2&#x2F;imgproc&#x2F;imgproc.hpp&gt;#include &lt;opencv2&#x2F;core&#x2F;core.hpp&gt;#include &lt;pthread.h&gt;using namespace cv;using namespace std;至此就可以与小车通信了\n4.控制小车首先需要在小车里配好WiringPi库和OPENCV库，我的小车是提前装好的，具体操作可以自行百度，同时电脑上也需配好OPENCV库以方便调试为了方便操作，客户端建议直接用MFC来写代码我就直接放网盘了https://pan.baidu.com/s/1wYwt1_OyDaCdooHXbyMfzw 提取码y5y0其中的OPENCV部分是我同学写的，所以我就不详细展开了。。。还有在Linux下编译时编译的指令后面还要加上WiringPi来加载WiringPi库至此就可以控制小车啦这可以说是我第一次对失误经行操作，以前都是干巴巴的写代码，这也让我再一次找到了编程的乐趣，这样的实训多我来说还是收获颇丰\n我的个人博客 amazingz6.github.io我的bilibili https://space.bilibili.com/66908429我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories\n","categories":[],"tags":["树莓派"]},{"title":"c++ java python大数加法","url":"http://yoursite.com/2019/07/30/c-java-python大数加法/","content":"转自：https://blog.csdn.net/weixin_43871885/article/details/97797871 \nc++代码#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 1000int a[MAXN],b[MAXN];int main(int argc, const char * argv[])&#123;    string str1,str2;//保存输入    long int len1,len2;    long int i,j,k;    int up;    /*输入流程*/    cin&gt;&gt;str1&gt;&gt;str2;    /*初始化各量*/    len1 = str1.length();    len2 = str2.length();    memset(a, 0, sizeof(a));    memset(b, 0, sizeof(b));    /*注意，必须倒着保存数据*/    for (i = len1 - 1, k = 0; i != -1; -- i)    &#123;        a[k] = str1[i] - &#x27;0&#x27;;        k++;    &#125;    for (j = len2 - 1, k = 0; j != -1; -- j)    &#123;        b[k] = str2[j] - &#x27;0&#x27;;        k++;    &#125;    for (i = 0, up = 0; i &lt; MAXN; ++ i)    &#123;        a[i] = a[i] + b[i] + up;        up = a[i] / 10;        a[i] %= 10;    &#125;    for (i = MAXN - 1; i != -1; -- i)    &#123;        if (a[i])        &#123;            break;        &#125;    &#125;    for (k = i; k != -1; --k)    &#123;        cout&lt;&lt;a[k];    &#125;    return 0;&#125;\n \njava代码package my;import java.math.BigInteger;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        BigInteger a, b;        Scanner in = new Scanner(System.in);            a = in.nextBigInteger();            b = in.nextBigInteger();            System.out.println(a + &quot; + &quot; + b + &quot; = &quot; + a.add(b) );            System.out.println();    &#125;&#125; \nPython大数代码a = int(input());b = int(input());print(a+b);\n我的个人博客 amazingz6.github.io我的CSDN https://blog.csdn.net/qq_44105654我的简书 https://www.jianshu.com/u/607ef08e5825我的github https://github.com/AmazingZ6?tab=repositories我的bilibili https://space.bilibili.com/66908429\n","categories":[],"tags":["算法"]},{"title":"my first blog","url":"http://yoursite.com/2019/07/27/my-first-blog/","content":"开始写博客啦！\n","categories":[],"tags":[]},{"title":"Hello World","url":"http://yoursite.com/2019/07/24/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n Quick Start\nCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","categories":[],"tags":[]}]